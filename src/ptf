#!/usr/bin/env python
"""
@package ptf

Packet Test Framework (ptf) top level script

To add a new command line option, edit both the config_default dictionary and
the config_setup function. The option's result will end up in the global
oftest.config dictionary.
"""

import sys
import argparse
from subprocess import Popen,PIPE
import logging
import unittest
import time
import os
import imp
import random
import signal
import fnmatch
import copy
from collections import OrderedDict


import logging
import pdb
import datetime


import pd_base_tests

from ptf import config
from ptf.testutils import *
from ptf.thriftutils import *
import ptf.dataplane as dataplane


from pal_rpc.ttypes import *
#from stful.p4_pd_rpc.ttypes import *
from HashFlow.p4_pd_rpc.ttypes import *
from conn_mgr_pd_rpc.ttypes import *
from mc_pd_rpc.ttypes import *
from devport_mgr_pd_rpc.ttypes import *
from res_pd_rpc.ttypes import *
from ptf_port import *



root_dir = os.path.dirname(os.path.realpath(__file__))
pydir = os.path.join(root_dir, 'src')
if os.path.exists(os.path.join(pydir, 'ptf')):
    # Running from source tree
    sys.path.insert(0, pydir)

import ptf
from ptf import config
import ptf.ptfutils

##@var DEBUG_LEVELS
# Map from strings to debugging levels
DEBUG_LEVELS = {
    'debug'              : logging.DEBUG,
    'verbose'            : logging.DEBUG,
    'info'               : logging.INFO,
    'warning'            : logging.WARNING,
    'warn'               : logging.WARNING,
    'error'              : logging.ERROR,
    'critical'           : logging.CRITICAL
}

##@var config_default
# The default configuration dictionary for PTF
config_default = {
    # Miscellaneous options
    "list"               : False,
    "list_test_names"    : False,
    "allow_user"         : False,

    # Test selection options
    "test_spec"          : "",
    "test_file"          : None,
    "test_dir"           : None,
    "test_order"         : "default",
    "test_order_seed"    : 0xaba,

    # Switch connection options
    "platform"           : "eth",
    "platform_args"      : None,
    "platform_dir"       : None,
    "interfaces"         : [],
    "device_sockets"     : [],  # when using nanomsg

    # Logging options
    "log_file"           : "ptf.log",
    "log_dir"            : None,
    "debug"              : "verbose",
    "profile"            : False,
    "profile_file"       : "profile.out",
    "xunit"              : False,
    "xunit_dir"          : "xunit",

    # Test behavior options
    "relax"              : False,
    "test_params"        : "None",
    "failfast"           : False,
    "fail_skipped"       : False,
    "default_timeout"    : 2.0,
    "default_negative_timeout" : 0.1,
    "minsize"            : 0,
    "random_seed"        : None,
    "disable_ipv6"       : False,
    "disable_vxlan"      : False,
    "disable_erspan"     : False,
    "disable_geneve"     : False,
    "disable_mpls"       : False,
    "disable_nvgre"      : False,
    "qlen"               : 100,
    "test_case_timeout"  : None,

    # Socket options
    "socket_recv_size"   : 4096,

    # Other configuration
    "port_map"           : {},
}

def config_setup():
    """
    Set up the configuration including parsing the arguments

    @return A pair (config, args) where config is an config
    object and args is any additional arguments from the command line
    """

    usage = "usage: ptf [options] --test-dir TEST_DIR [tests]"

    description = "Description is deleted."
    
    class ActionInterface(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            # Parse --interface
            def check_interface(value):
                try:
                    dev_and_port, interface = value.split('@', 1)
                    dev_and_port = dev_and_port.split("-")
                    if len(dev_and_port) == 1:
                        dev, port = 0, int(dev_and_port[0])
                    elif len(dev_and_port) == 2:
                        dev, port = int(dev_and_port[0]), int(dev_and_port[1])
                    else:
                        raise ValueError("")
                except ValueError:
                    parser.error("incorrect interface syntax (got %s, expected 'port@interface' or 'device-port@interface')" % repr(value))
                return (dev, port, interface)

            assert(type(values) is str)
            getattr(namespace, self.dest).append(check_interface(values))

    class ActionDeviceSocket(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            # Parse --device-socket
            def check_device_socket(value):
                def parse_ports(ports):
                    port_set = set()
                    try:
                        ports = ports.strip("{}")
                        ports = ports.split(",")
                    except:
                        raise ValueError("")
                    for port in ports:
                        try:
                            p = int(port)
                            port_set.add(p)
                            continue
                        except:
                            pass
                        try:
                            p1, p2 = port.split("-", 1)
                            p1, p2 = int(p1), int(p2)
                            for p in xrange(p1, p2 + 1):  # p2 included
                                port_set.add(p)
                        except:
                            raise ValueError("")
                    return port_set

                try:
                    dev_and_port, addr = value.split('@', 1)
                    if dev_and_port[0] == '{':
                        dev, ports = (0, parse_ports(dev_and_port))
                    else:
                        dev_and_port = dev_and_port.split("-", 1)
                        if len(dev_and_port) != 2:
                            raise ValueError("")
                        dev, ports = (int(dev_and_port[0]),
                                      parse_ports(dev_and_port[1]))
                except ValueError:
                    parser.error("incorrect device-socket syntax (got %s, expected something of the form 0-{1,2,5-8}@<socket addr>)" % repr(value))
                return (dev, ports, addr)

            assert(type(values) is str)
            getattr(namespace, self.dest).append(check_device_socket(values))

    class ActionTestDir(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            assert(type(values) is str)
            if not os.path.isdir(values):
                parser.error("invalid value for --test-dir: directory %s does not exist" % values)
            setattr(namespace, self.dest, values)

    parser = argparse.ArgumentParser(version="ptf 0.1",
                                     usage=usage,
                                     description=description)

    # Set up default values
    parser.set_defaults(**config_default)

    parser.add_argument("test_specs", nargs="*",
                        help="Tests / Groups to run")

    parser.add_argument("--list", action="store_true",
                        help="List all tests and exit")
    parser.add_argument("--list-test-names", action='store_true',
                        help="List test names matching the test spec and exit")
    parser.add_argument("--allow-user", action="store_true",
                        help="Proceed even if ptf is not run as root")

    parser.add_argument("--pypath", dest="pypath", action="append")

    group = parser.add_argument_group("Test selection options")
    group.add_argument("-f", "--test-file", help="File of tests to run, one per line")
    group.add_argument("--test-dir", type=str, action=ActionTestDir,
                       required=True, help="Directory containing tests")
    test_order_help = """Choose the order in which the tests will be run:"""
    group.add_argument("--test-order",
                       choices=["default", "lexico", "rand"],
                       help=test_order_help)
    group.add_argument("--test-order-seed", type=int,
                       help="Specify seed to randomize test order")

    group = parser.add_argument_group("Switch connection options")
    group.add_argument("-P", "--platform", help="Platform module name")
    group.add_argument("-a", "--platform-args", help="Custom arguments for the platform")
    group.add_argument("--platform-dir", type=str, help="Directory containing platform modules")
    group.add_argument("--interface", "-i", type=str, dest="interfaces", metavar="INTERFACE", action=ActionInterface,
                       help="Specify a port number and the dataplane interface to use. May be given multiple times. Example: 1@eth1 or 0-1@eth2 (use eth2 as port 1 of device 0)")
    group.add_argument("--device-socket", type=str, dest="device_sockets", metavar="DEVICE-SOCKET", action=ActionDeviceSocket,
                       help="Specify the nanomsg socket to use to send / receive packets for a given device, as well as the ports to enable on the device. May be given multiple times. Example: 0-{1,2,5-8}@<socket addr>")

    group = parser.add_argument_group("Logging options")
    group.add_argument("--log-file", help="Name of log file")
    group.add_argument("--log-dir", help="Name of log directory")
    dbg_lvl_names = sorted(DEBUG_LEVELS.keys(), key=lambda x: DEBUG_LEVELS[x])
    group.add_argument("--debug", choices=dbg_lvl_names,
                       help="Debug lvl: debug, info, warning, error, critical")
    group.add_argument("--verbose", action="store_const", dest="debug",
                       const="verbose", help="Shortcut for --debug=verbose")
    group.add_argument("-q", "--quiet", action="store_const", dest="debug",
                       const="warning", help="Shortcut for --debug=warning")
    group.add_argument("--profile", action="store_true", help="Enable Python profiling")
    group.add_argument("--profile-file", help="Output file for Python profiler")
    group.add_argument("--xunit", action="store_true", help="Enable xUnit-formatted results")
    group.add_argument("--xunit-dir", help="Output directory for xUnit-formatted results")

    group = parser.add_argument_group("Test behavior options")
    group.add_argument("--relax", action="store_true",
                      help="Relax packet match checks allowing other packets")
    group.add_argument("--failfast", action="store_true",
                      help="Stop running tests as soon as one fails")
    test_params_help = """Set test parameters: key=val;... (see --list)
    """
    group.add_argument("-t", "--test-params", help=test_params_help)
    group.add_argument("--fail-skipped", action="store_true",
                       help="Return failure if any test was skipped")
    group.add_argument("--default-timeout", type=float,
                       help="Timeout in seconds for most operations")
    group.add_argument("--default-negative-timeout", type=float,
                       help="Timeout in seconds for negative checks")
    group.add_argument("--minsize", type=int,
                       help="Minimum allowable packet size on the dataplane.")
    group.add_argument("--random-seed", type=int,
                       help="Random number generator seed")
    group.add_argument("--disable-ipv6", action="store_true",
                       help="Disable IPv6 tests")
    group.add_argument("--qlen", type=int,
                       help="Default queue length ")
    group.add_argument("--test-case-timeout", type=int,
                       help="Timeout for each test case, 0 means no timeout")

    group.add_argument("--disable-vxlan", action="store_true",
                       help="Disable VXLAN (do not import from scapy even if supported)")
    group.add_argument("--disable-geneve", action="store_true",
                       help="Disable GENEVE (do not import from scapy even if supported)")
    group.add_argument("--disable-erspan", action="store_true",
                       help="Disable ERSPAN (do not import from scapy even if supported)")
    group.add_argument("--disable-mpls", action="store_true",
                       help="Disable MPLS (do not import from scapy even if supported)")
    group.add_argument("--disable-nvgre", action="store_true",
                       help="Disable NVGRE (do not import from scapy even if supported)")

    group = parser.add_argument_group("Socket options")
    group.add_argument("--socket-recv-size", type=int,
                       help="When using raw sockets, specify the size of the buffer used to receive packets with socket.recv.")

    # Might need this if other parsers want command line
    # parser.allow_interspersed_args = False
    args = parser.parse_args()
    if args.pypath:
        for p in args.pypath:
            sys.path.append(p)
    # Convert args from a Namespace to a plain dictionary
    config = config_default.copy()
    for key in config.keys():
        config[key] = getattr(args, key)
    return (config, args)

#
# Main script
#
# Setup global configuration


(new_config, args) = config_setup()
ptf.config.update(new_config)

if config["platform_dir"] is None:
    from ptf import platforms
    config["platform_dir"] = os.path.dirname(os.path.abspath(platforms.__file__))

# Allow platforms to import each other
sys.path.append(config["platform_dir"])
# Load the platform module
platform_name = config["platform"]
logging.info("Importing platform: " + platform_name)
platform_mod = None
try:
    platform_mod = imp.load_module(platform_name, *imp.find_module(platform_name, [config["platform_dir"]]))
except:
    logging.warn("Failed to import " + platform_name + " platform module")
    raise

try:
    platform_mod.platform_config_update(config)
except:
    logging.warn("Could not run platform host configuration")
    raise

# Remove python's signal handler which raises KeyboardError. Exiting from an
# exception waits for all threads to terminate which might not happen.
signal.signal(signal.SIGINT, signal.SIG_DFL)

# Set up the dataplane
ptf.dataplane_instance = ptf.dataplane.DataPlane(config)
#for port_id, ifname in config["port_map"].items():
#    device, port = port_id
#    ptf.dataplane_instance.port_add(ifname, device, port)
##########Begin##########

dev_id = 0
PORT_TBL_SIZE = 288
IFID_TBL_SIZE = 25000
SIP_SAMPLER_TBL_SIZE = 85000
SIP_SAMPLER_REG_SIZE = 143360
SCRATCH_REG_SIZE = 4096
NEXT_HOP_TBL_SIZE = 4096
IP_ROUTE_TBL_SIZE = 512
EGR_PORT_TBL_SIZE = 16384
BLOOM_FILTER_REG_SIZE = 256*1024
MAX_PORT_COUNT = 456
ECMP_REG_SIZE = 128*1024
LAG_REG_SIZE = 128*1024

RECIRC_TYPE_PG_PORT_DOWN = 1
RECIRC_TYPE_PG_RECIRC    = 2

class TestOneBit(pd_base_tests.ThriftInterfaceDataPlane):
    def __init__(self):
        pd_base_tests.ThriftInterfaceDataPlane.__init__(self, ["HashFlow"])

    def runTest(self):
        print
        try:
#        if True:
            dev_tgt = DevTarget_t(dev_id, hex_to_i16(0xFFFF))
            sess_hdl = self.conn_mgr.client_init()
#            port_tbl = PortTable(self, sess_hdl, dev_id)
#            ifid_tbl = IfidTbl(self, sess_hdl, dev_id, port_tbl)

            # Set default action entries for tables with stateful
#            self.client.one_bit_read_1_set_default_action_run_one_bit_read_1(sess_hdl, dev_tgt)
#            self.client.one_bit_read_2_set_default_action_run_one_bit_read_2(sess_hdl, dev_tgt)

            # Set port 0 with ifid 0 to drop
#            port_tbl.add(swports[-1], 0)
#            ifid_tbl.add(0)
            self.conn_mgr.complete_operations(sess_hdl)
            print "count:"
            for i in range(10):
                x = self.client.register_read_count(sess_hdl, dev_tgt, i, HashFlow_register_flags_t(read_hw_sync = True) )
                print i, ":", x
#            print "Reg ob1[1] =", x
#            x = self.client.register_read_flow_pktcnt_2(sess_hdl, dev_tgt, 2, HashFlow_register_flags_t(read_hw_sync = True) )
#            print "Reg ob2[2] =", x
            sys.stdout.flush()

            return

            pkt = simple_udp_packet(eth_dst='00:DD:DD:DD:DD:DD', pktlen=100)
            send_packet(self, swports[-1], str(pkt))
            verify_no_other_packets(self)

            # Set all one bit tables to have a value of 1
            self.client.register_write_flow_pktcnt_1(sess_hdl, dev_tgt, 1, 1)
            self.client.register_write_flow_pktcnt_2(sess_hdl, dev_tgt, 2, 1)
            self.conn_mgr.complete_operations(sess_hdl)
            x = self.client.register_read_flow_pktcnt_1(sess_hdl, dev_tgt, 1, HashFlow_register_flags_t(read_hw_sync = True) )
            print "Reg ob1[1] =", x
            x = self.client.register_read_flow_pktcnt_2(sess_hdl, dev_tgt, 2, HashFlow_register_flags_t(read_hw_sync = True) )
            print "Reg ob2[2] =", x
            sys.stdout.flush()

            pkt = simple_udp_packet(eth_dst='00:FF:FF:FF:FF:FF', pktlen=80)
            send_packet(self, swports[-1], str(pkt))
            verify_packets(self, pkt, [swports[-1]])
            verify_no_other_packets(self)

        finally:
            print "finally"
case = TestOneBit()
case.setUp()
case.runTest()
##########End##########


# Shutdown the dataplane
ptf.dataplane_instance.kill()
ptf.dataplane_instance = None
